"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../index");
var _a = index_1.default(), getString = _a.getString, getNumber = _a.getNumber, getBoolean = _a.getBoolean, getStringArray = _a.getStringArray, getNumberArray = _a.getNumberArray, getBooleanArray = _a.getBooleanArray, getStringMap = _a.getStringMap, getNumberMap = _a.getNumberMap, getBooleanMap = _a.getBooleanMap;
describe('getString', function () {
    var testShape = {
        test: {
            this: {
                one: 'yes',
                too: 2,
            },
        },
    };
    it('should return nested string when found', function () {
        var value = getString(testShape, function (obj) { return obj.test.this.one; }, 'fallback');
        expect(value).toBe('yes');
    });
    it('should return fallback string when not found', function () {
        var value = getString(testShape, function (obj) { return obj.this.is.not.here; }, 'fallback');
        expect(value).toBe('fallback');
    });
    it('should return fallback string when type mismatch', function () {
        var value = getString(testShape, function (obj) { return obj.test.this.too; }, 'fallback');
        expect(value).toBe('fallback');
    });
    it('should return fallback string when type mismatch', function () {
        var value = getString(testShape, function (obj) { return obj; }, 'fallback');
        expect(value).toBe('fallback');
    });
});
describe('getNumber', function () {
    var testShape = {
        test: {
            this: {
                one: 999,
                too: 'nada',
            },
        },
    };
    it('should return nested number when found', function () {
        var value = getNumber(testShape, function (obj) { return obj.test.this.one; }, 101);
        expect(value).toBe(999);
    });
    it('should return fallback number when not found', function () {
        var value = getNumber(testShape, function (obj) { return obj.this.is.not.here; }, 101);
        expect(value).toBe(101);
    });
    it('should return fallback number when type mismatch', function () {
        var value = getNumber(testShape, function (obj) { return obj.test.this.too; }, 101);
        expect(value).toBe(101);
    });
    it('should return fallback number when type mismatch', function () {
        var value = getNumber(testShape, function (obj) { return obj; }, 101);
        expect(value).toBe(101);
    });
});
describe('getBoolean', function () {
    var testShape = {
        test: {
            this: {
                one: true,
                too: 'nada',
            },
        },
    };
    it('should return nested boolean when found', function () {
        var value = getBoolean(testShape, function (obj) { return obj.test.this.one; }, false);
        expect(value).toBe(true);
    });
    it('should return fallback boolean when not found', function () {
        var value = getBoolean(testShape, function (obj) { return obj.this.is.not.here; }, false);
        expect(value).toBe(false);
    });
    it('should return fallback number when type mismatch', function () {
        var value = getBoolean(testShape, function (obj) { return obj.test.this.too; }, false);
        expect(value).toBe(false);
    });
    it('should return fallback number when type mismatch', function () {
        var value = getBoolean(testShape, function (obj) { return obj; }, false);
        expect(value).toBe(false);
    });
});
describe('getStringArray', function () {
    var testShape = {
        test: {
            this: {
                one: ['this', 'better', 'work'],
                too: 'nada',
            },
        },
    };
    it('should return nested string array when found', function () {
        var value = getStringArray(testShape, function (obj) { return obj.test.this.one; }, []);
        expect(value).toStrictEqual(['this', 'better', 'work']);
    });
    it('should return fallback string array when not found', function () {
        var value = getStringArray(testShape, function (obj) { return obj.this.is.not.here; }, ['test']);
        expect(value).toStrictEqual(['test']);
    });
    it('should return fallback string array when type mismatch', function () {
        var value = getStringArray(testShape, function (obj) { return obj.test.this.too; }, []);
        expect(value).toStrictEqual([]);
    });
    it('should return fallback string array when type mismatch', function () {
        var value = getStringArray(testShape, function (obj) { return obj; }, []);
        expect(value).toStrictEqual([]);
    });
});
describe('getNumberArray', function () {
    var testShape = {
        test: {
            this: {
                one: [1, 2, 3],
                too: 4,
            },
        },
    };
    it('should return nested number array when found', function () {
        var value = getNumberArray(testShape, function (obj) { return obj.test.this.one; }, []);
        expect(value).toStrictEqual([1, 2, 3]);
    });
    it('should return fallback number array when not found', function () {
        var value = getNumberArray(testShape, function (obj) { return obj.this.is.not.here; }, [999]);
        expect(value).toStrictEqual([999]);
    });
    it('should return fallback number array when type mismatch', function () {
        var value = getNumberArray(testShape, function (obj) { return obj.test.this.too; }, []);
        expect(value).toStrictEqual([]);
    });
    it('should return fallback number array when type mismatch', function () {
        var value = getNumberArray(testShape, function (obj) { return obj; }, []);
        expect(value).toStrictEqual([]);
    });
});
describe('getBooleanArray', function () {
    var testShape = {
        test: {
            this: {
                one: [false, true, false],
                too: true,
            },
        },
    };
    it('should return nested boolean array when found', function () {
        var value = getBooleanArray(testShape, function (obj) { return obj.test.this.one; }, []);
        expect(value).toStrictEqual([false, true, false]);
    });
    it('should return fallback boolean array when not found', function () {
        var value = getBooleanArray(testShape, function (obj) { return obj.this.is.not.here; }, [true]);
        expect(value).toStrictEqual([true]);
    });
    it('should return fallback boolean array when type mismatch', function () {
        var value = getBooleanArray(testShape, function (obj) { return obj.test.this.too; }, []);
        expect(value).toStrictEqual([]);
    });
    it('should return fallback boolean array when type mismatch', function () {
        var value = getBooleanArray(testShape, function (obj) { return obj; }, []);
        expect(value).toStrictEqual([]);
    });
});
describe('getStringMap', function () {
    var testShape = {
        test: {
            this: {
                one: { one: 'please', two: 'test', three: 'me' },
                too: true,
            },
        },
    };
    it('should return nested string map when found', function () {
        var value = getStringMap(testShape, function (obj) { return obj.test.this.one; }, {});
        expect(value).toStrictEqual({ one: 'please', two: 'test', three: 'me' });
    });
    it('should return fallback string map when not found', function () {
        var value = getStringMap(testShape, function (obj) { return obj.this.is.not.here; }, { fallback: 'returned' });
        expect(value).toStrictEqual({ fallback: 'returned' });
    });
    it('should return fallback string map when type mismatch', function () {
        var value = getStringMap(testShape, function (obj) { return obj.test.this.too; }, {});
        expect(value).toStrictEqual({});
    });
    it('should return fallback string map when type mismatch', function () {
        var value = getStringMap(testShape, function (obj) { return obj; }, {});
        expect(value).toStrictEqual({});
    });
});
describe('getNumberMap', function () {
    var testShape = {
        test: {
            this: {
                one: { one: 1, two: 2, three: 3 },
                too: true,
            },
        },
    };
    it('should return nested number map when found', function () {
        var value = getNumberMap(testShape, function (obj) { return obj.test.this.one; }, {});
        expect(value).toStrictEqual({ one: 1, two: 2, three: 3 });
    });
    it('should return fallback number map when not found', function () {
        var value = getNumberMap(testShape, function (obj) { return obj.this.is.not.here; }, { fallback: 999 });
        expect(value).toStrictEqual({ fallback: 999 });
    });
    it('should return fallback number map when type mismatch', function () {
        var value = getNumberMap(testShape, function (obj) { return obj.test.this.too; }, {});
        expect(value).toStrictEqual({});
    });
    it('should return fallback number map when type mismatch', function () {
        var value = getNumberMap(testShape, function (obj) { return obj; }, {});
        expect(value).toStrictEqual({});
    });
});
describe('getBooleanMap', function () {
    var testShape = {
        test: {
            this: {
                one: { one: true, two: false, three: true },
                too: true,
            },
        },
    };
    it('should return nested boolean map when found', function () {
        var value = getBooleanMap(testShape, function (obj) { return obj.test.this.one; }, {});
        expect(value).toStrictEqual({ one: true, two: false, three: true });
    });
    it('should return fallback boolean map when not found', function () {
        var value = getBooleanMap(testShape, function (obj) { return obj.this.is.not.here; }, { fallback: true });
        expect(value).toStrictEqual({ fallback: true });
    });
    it('should return fallback boolean map when type mismatch', function () {
        var value = getBooleanMap(testShape, function (obj) { return obj.test.this.too; }, {});
        expect(value).toStrictEqual({});
    });
    it('should return fallback boolean map when type mismatch', function () {
        var value = getBooleanMap(testShape, function (obj) { return obj; }, {});
        expect(value).toStrictEqual({});
    });
});
//# sourceMappingURL=getters.test.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../index");
describe('access', function () {
    it('should call the fallback callback when prop doesnt exist', function () {
        var fallbackCallbackMock = jest.fn();
        var getStr = index_1.default(fallbackCallbackMock).getString;
        var testShape = {
            test: {
                this: {
                    one: 999,
                    too: 'nada',
                },
            },
        };
        getStr(testShape, function (obj) { return obj.prop.doesnt.exist; }, 'fallback');
        expect(fallbackCallbackMock).toBeCalledWith(expect.objectContaining({
            name: expect.stringContaining('PropertyMissingException'),
        }));
    });
    it('should call the fallback callback when prop undefined', function () {
        var fallbackCallbackMock = jest.fn();
        var getStr = index_1.default(fallbackCallbackMock).getString;
        var testShape = {
            test: {
                this: {
                    one: 999,
                    too: 'nada',
                },
            },
        };
        getStr(testShape, function (obj) { return obj.test.this.three; }, 'fallback');
        expect(fallbackCallbackMock).toBeCalledWith(expect.objectContaining({
            name: expect.stringContaining('PropertyUndefinedException'),
        }));
    });
    it('should call the fallback callback when type mismatch', function () {
        var fallbackCallbackMock = jest.fn();
        var getStr = index_1.default(fallbackCallbackMock).getString;
        var testShape = {
            test: {
                this: {
                    one: 999,
                    too: 'nada',
                },
            },
        };
        getStr(testShape, function (obj) { return obj.test.this.one; }, 'fallback');
        expect(fallbackCallbackMock).toBeCalledWith(expect.objectContaining({
            name: expect.stringContaining('PropertyTypeMismatchException'),
        }));
    });
    it('should not call the fallback callback when get successful', function () {
        var fallbackCallbackMock = jest.fn();
        var getStr = index_1.default(fallbackCallbackMock).getString;
        var testShape = {
            test: {
                this: {
                    one: 999,
                    too: 'nada',
                },
            },
        };
        getStr(testShape, function (obj) { return obj.test.this.too; }, 'fallback');
        expect(fallbackCallbackMock).not.toBeCalled();
    });
});
//# sourceMappingURL=index.test.js.map